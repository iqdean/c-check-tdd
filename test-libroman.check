#include "romancalc.h"

#suite utils

/* int chk_for_valid_roman_digit(char roman_digit) 
 * @param char roman_digit
 *   ONLY valid roman_digits:  M D C L X V I
 * @return 
 *   0 - SUCCESS, input is a valid roman_digit
 *   1 - ERROR, input IS NOT a valid roman_digit    
 */

#tcase tc1_chk_for_valid_roman_digit

#test tc1_1_pos_chk
      printf("tc1_1_pos_chk: int chk_for_valid_roman_digit(char roman_digit)\n");
      char romans[] = { 'M',  'D', 'C','L','X','V','I'};
      int expected[]= {  0,    0,   0,  0,  0,  0,  0 };
      int ec;
      int i;
      for (i=0; i < 7; i++){
      	  ec = chk_for_valid_roman_digit(romans[i]);
	  printf("roman_digit in: %c expected_out: %d actual_out: %d \n", romans[i], expected[i], ec);
	  fail_unless(ec == 0, "tc1.1 failed");
	  }

#test tc1_2_neg_chk
      printf("tc1_1_neg_chk: int chk_for_valid_roman_digit(char roman_digit)\n");
      char romans[] = { 'm',  'd', 'c','l','x','v','i', 'A', 'B', 'Q', 'J', 'p', 'q', 'r', 's'};
      int expected[]= {  1,    1,   1,  1,  1,  1,  1,   1 ,  1,   1,   1,   1,   1,   1,   1 };
      int ec;
      int i;
      for (i=0; i < 15; i++){
      	  ec = chk_for_valid_roman_digit(romans[i]);
	  printf("roman_digit in: %c expected_out: %d actual_out: %d \n", romans[i], expected[i], ec);
	  fail_unless(ec == 1, "tc1.2 failed");
	  }

#tcase tc2_roman2base10

/* int roman2base10(char roman_digit) 
 * convert roman digit to base10 value
 * 
 * @param char roman_digit  : I V X  L   C  D   M      Invalid Digit
 * @return int base10 value : 1 5 10 50 100 500 1000   0
 */

#test tc2_1_pos_chk
      printf("tc2_1_pos_chk: int roman2base10(char roman_digit)\n");
      char romans[] = { 'M',  'D', 'C','L','X','V','I'};
      int valid[] =   {1000,  500, 100, 50, 10, 5, 1  }; 
      int ec;
      int i;
      for (i=0; i < 7; i++){
      	  ec = roman2base10(romans[i]);
	  printf("roman_digit in: %c expected_out: %d actual_out: %d \n", romans[i], valid[i], ec);
	  fail_unless(ec == valid[i], "tc2.1 failed");
	  }

#test tc2_2_neg_chk
      char romans[] = { 'm',  'd', 'c','l','x','v','i'};
      int valid[] =   { 0,     0,   0,  0,  0,  0 , 0  }; 
      int ec;
      int i;
      for (i=0; i < 7; i++){
      	  ec = roman2base10(romans[i]);
	  fail_unless(ec == valid[i], "tc2.2 failed");
	  }

#tcase tc3_toBase10fromRoman

/*  int toBase10fromRoman(char *p)
 *  @param  char *p   Input- a uncompacted or compacted roman numeral
 *  @return int sum   base10 number representation of Input
 *  if a subtractive appears with a I, X, or C to the left of a "larger" symbol
 *  we need to substitute the pair for the correct numeric value
 * *p     *p    int
 * DCCCC  CM    900   
 * CCCC   CD    400
 * LXXXX  XC     90
 * XXXX   XL     40
 * VIIII  IX      9 
 * IIII   IV      4  
*/

#test tc3_1_chk_compacted
      printf("tc3_1_chk_compacted: int toBase10fromRoman(char *p)\n");
      char *compact[] = {"MMMCMXCIX", "CM",    "CD",   "XC",    "XL",   "IX",    "IV"  };
      int expect[]    = {       3999,  900,     400,    90,      40,     9,       4    };
      int ec;
      int i;
      for (i=0; i<7; i++){
      	  ec = toBase10fromRoman(compact[i]);
	  printf("roman_in: %s base10_out: %d expected: %d\n", compact[i], ec, expect[i]);
	  fail_unless(ec == expect[i], "tc3.1 failed");
	  }

#test tc3_2_chk_uncompacted
      printf("tc3_2_chk_uncompacted: int toBase10fromRoman(char *p)\n");
      char *uncompact[] = {"MMMMCMXCIX","DCCCC", "CCCC", "LXXXX", "XXXX", "VIIII", "IIII"};
      int expect[]      = {        4999,    900,     400,    90,      40,     9,       4 };
      int ec;
      int i;
      for (i=0; i<7; i++){
      	  ec = toBase10fromRoman(uncompact[i]);
	  printf("roman_in: %s base10_out: %d expected: %d\n", uncompact[i], ec, expect[i]);
	  fail_unless(ec == expect[i], "tc3.2 failed");
	  }

#tcase tc4_toRomanFromBase10

/* int toRomanFromBase10(int base10, char *roman)
 * @param int base10 - input  a base10 num bt 1 (MIN_ROMAN) & 3999 (MAX_ROMAN)
 * @param char *roman- output base10 converted to a compacted roman numeral
 *                     caller allocates memory for char *roman
 * @return 
 *   0 - Success
 *   1 - Error   base10 input is out-of-range  base10 <= 0 || base10 > MAX_ROMAN
 * 
 *    *roman    base10   @return
 *    output    input
 *        |      |
 * DCCCC  CM    900       0
 * CCCC   CD    400       0
 * LXXXX  XC     90       0
 * XXXX   XL     40       0
 * VIIII  IX      9       0
 * IIII   IV      4       0
 *        na      0       1
 *        na   4000       1
 */

#test tc4_1_chk_compacted
     printf("tc4_1_chk_compacted:  int toRomanFromBase10(int base10, char *roman) \n");
     int base10_in[]  = { 900,     400,    90,      40,     9,       4    };
     char *expected[] = {"CM",    "CD",  "XC",    "XL",   "IX",    "IV"  };     
     //char *myroman = (char *) malloc(100);  // caller allocates space
     char myroman[100];
     myroman[0]='\0'; // empty string
     int ec;
     int i;
     for (i=0; i<6; i++){
     	 //ec = toRomanFromBase10(base10_in[i], myroman);
     	 ec = toRomanFromBase10(base10_in[i], &myroman[0]);
	 fail_unless(ec == 0, "tc4.1 failed w ec: %d", ec);
	 printf("base10_in: %d  roman_out: %s expected: %s\n", base10_in[i], myroman, expected[i]);
	 ck_assert_str_eq(myroman, expected[i]);
	 }
     //free(myroman);

#test tc4_2_chk_bounds
     printf("tc4_2_chk_bounds:  int toRomanFromBase10(int base10, char *roman) \n");
     int base10_in[]  = { 0,      1,   3999,         4000   };
     char *expected[] = {"ec1",  "I",  "MMMCMXCIX",  "ec1"   };     
     char myroman[100];
     myroman[0]='\0'; // empty string
     int ec;
     int i;
     for (i=0; i<4; i++){
     	 ec = toRomanFromBase10(base10_in[i], &myroman[0]);
	 switch(i){
	 case 0:
	      printf("base10_in: %d  roman_out: %s expected: %s ec: %d\n", base10_in[i], myroman, expected[i], ec);
	      fail_unless(ec == 1, "tc4.2 failed w ec: %d", ec);
	      break;
	 case 1:
	      fail_unless(ec == 0, "tc4.2 failed w ec: %d", ec);
	      printf("base10_in: %d  roman_out: %s expected: %s\n", base10_in[i], myroman, expected[i]);
	      ck_assert_str_eq(myroman, expected[i]);
	      myroman[0]='\0'; // empty string	      
	      break;
	 case 2:
	      fail_unless(ec == 0, "tc4.2 failed w ec: %d", ec);
	      printf("base10_in: %d  roman_out: %s expected: %s\n", base10_in[i], myroman, expected[i]);
	      ck_assert_str_eq(myroman, expected[i]);
	      myroman[0]='\0'; // empty string	      
	      break;
	 case 3:
	      printf("base10_in: %d  roman_out: %s expected: %s ec: %d\n", base10_in[i], myroman, expected[i], ec);
	      fail_unless(ec == 1, "tc4.2 failed w ec: %d", ec);
	      break;
	 default:
	      break;
	 }
     }

/*
 * int add2Romans(char *b, char *a, char *result)
 */

#suite add2Romans

/* int add2Romans( char *b, char *a, char *result)
 * @param char *b  input roman number b
 * @param char *a  input roman number a
 * @param char *result  output b+a
 * @return
 *  0 - success  result = b + a
 * ERRORS
 *  1 - invalid inputs: invalid digits detected in roman numerals a or b
 *      if [ (a || b) != ['M' || 'D' || 'C' || 'L' || 'X' || 'V' || 'I'] 
 *  2 - invalid inputs: inputs a or b are out of range
 *      if [ (a <= 0)||(b <= 0)||(a > 3999)||(b > 3999) ]
 *  3 - invalid output, b+a will result in a out of range number   
 *      if (a + b) > 3999 
 */

#tcase tc5_add2Romans

#test tc5_1_chk_invalid_b
      printf("tc5_1_chk_invalid_b:  int add2Romans( char *b, char *a, char *result) \n");
      char *b_in[] = {"MMMCMXCiX", "dCCCc", "cCCa", "qXXba", "xXXX", "VIIiI", "IIiI"};
      char *a_in[] = {"MMMCMXCIX", "CM",    "CD",   "XC",    "XL",   "IX",    "IV"  };
      int ec_out[] = {         1,       1,       1,    1,      1,     1,       1    };
      char result[100];
      result[0] = '\0'; //empty string
      int ec;
      int i;
      for (i=0; i<7; i++){
     	 ec = add2Romans(b_in[i], a_in[i], &result[0]);
	 printf("b_in: %s  a_in: %s expected_ec: %d actual_ec: %d\n", b_in[i], a_in[i], ec_out[i], ec);
	 fail_unless(ec == 1, "tc5_1 failed w ec: %d", ec);
	 }

#test tc5_2_chk_invalid_a
      printf("tc5_2_chk_invalid_a:  int add2Romans( char *b, char *a, char *result) \n");
      char *a_in[] = {"MMMCMXCiX", "dCCCc", "cCCa", "qXXba", "xXXX", "VIIiI", "IIiI"};
      char *b_in[] = {"MMMCMXCIX", "CM",    "CD",   "XC",    "XL",   "IX",    "IV"  };
      int ec_out[] = {         1,       1,       1,    1,      1,     1,       1    };
      char result[100];
      result[0] = '\0'; //empty string
      int ec;
      int i;
      for (i=0; i<7; i++){
     	 ec = add2Romans(b_in[i], a_in[i], &result[0]);
	 printf("b_in: %s  a_in: %s expected_ec: %d actual_ec: %d\n", b_in[i], a_in[i], ec_out[i], ec);
	 fail_unless(ec == 1, "tc5_2 failed w ec: %d", ec);
	 }

#test tc5_3_chk_invalid_ab
      printf("tc5_3_chk_invalid_ab:  int add2Romans( char *b, char *a, char *result) \n");
      char *a_in[] = {"MMMCMXCiX", "dCCCc", "cCCa", "qXXba", "xXXX", "VIIiI", "IIiI"};
      char *b_in[] = {"MMMCMXCiX", "dCCCc", "cCCa", "qXXba", "xXXX", "VIIiI", "IIiI"};
      int ec_out[] = {         1,       1,       1,    1,      1,     1,       1    };
      char result[100];
      result[0] = '\0'; //empty string
      int ec;
      int i;
      for (i=0; i<7; i++){
     	 ec = add2Romans(b_in[i], a_in[i], &result[0]);
	 printf("b_in: %s  a_in: %s expected_ec: %d actual_ec: %d\n", b_in[i], a_in[i], ec_out[i], ec);
	 fail_unless(ec == 1, "tc5_3 failed w ec: %d", ec);
	 }

#test tc5_4_chk_valid_ab
      printf("tc5_4_chk_valid_ab:  int add2Romans( char *b, char *a, char *result) \n");
      char *a_in[] = {   "I", "II", "III", "IIII",    "V", "VI", "VII"};
      char *b_in[] = {"VIII", "IX",   "X",  "XII", "XIII", "XIV", "VI"};
      int ec_out[] = { 0,      0,      0,    0,      0,     0,      0 };
      char result[100];
      result[0] = '\0'; //empty string
      int ec;
      int i;
      for (i=0; i<7; i++){
     	 ec = add2Romans(b_in[i], a_in[i], &result[0]);
	 printf("b_in: %s  a_in: %s expected_ec: %d actual_ec: %d result: %s\n", b_in[i], a_in[i], ec_out[i], ec, &result[0]);
	 fail_unless(ec == 0, "tc5_4 failed w ec: %d", ec);
	 }

#test tc5_5_invalidIORange
      printf("tc5_5_invalidIORange:  int add2Romans( char *b, char *a, char *result) \n");
      char *b_in[] = {"MMMCMXCIII",  "MMMCMXCX",  "MMMCMXCV",  "X"  };
      char *a_in[] = {         "I",         "I",         "X", "IV"  };
      //char rslt[] =  {"MMMCMXCIV",       "NA",       "NA", "XIV"  };
      int ec_out[] = {          0,           2,           3,    0   };
      char result[100];

      int ec;
      int i;
      for (i=0; i<4; i++){
      	 result[0] = '\0'; //empty string
     	 ec = add2Romans(b_in[i], a_in[i], &result[0]);
	 printf("b_in: %s  a_in: %s expected_ec: %d actual_ec: %d, result: %s\n", b_in[i], a_in[i], ec_out[i], ec, &result[0]);
	 switch(i){
	 case 0:
	      fail_unless(ec == 0, "tc5.5 failed w ec: %d", ec);
	      break;
	 case 1:
	      fail_unless(ec == 2, "tc5.5 failed w ec: %d", ec);
	      break;
	 case 2:
	      fail_unless(ec == 3, "tc5.5 failed w ec: %d", ec);
	      break;
	 case 3:
	      fail_unless(ec == 0, "tc5.5 failed w ec: %d", ec);
	      break;
	 default:
	      break;
	 }	 
      }

#test tc5_7_validAdditions
      printf("tc5_7_validAdditions:  int add2Romans( char *b, char *a, char *result) \n");
      char *b_in[] = {"CCCLXIX",  "MMCCCXXXXVIII", "DCCCC", "LXXXX",    "LXI",  "VI",  "VII"};
      char *a_in[] = {"DCCCXLV",              "I",     "X", "CXXII",  "CXXII", "XIV",   "VI"};
      char *expect[]={ "MCCXIV",      "MMCCCXLIX",   "CMX", "CCXII", "CLXXXIII", "XX", "XIII"};
      char result[100];
      int ec;
      int i;
      for (i=0; i<7; i++){
         result[0] = '\0'; //empty string
     	 ec = add2Romans(b_in[i], a_in[i], &result[0]);
	 printf("b_in: %s  a_in: %s expected: %s actual: %s ec: %d\n", b_in[i], a_in[i], expect[i], &result[0], ec);
	 ck_assert_str_eq(&result[0], expect[i]);
	 }

/* int subtract2Romans( char *b, char *a, char *result)
 * @param char *b  input roman number b
 * @param char *a  input roman number a
 * @param char *result  output b-a
 * @return 
 *  0 - success    result = b-a
 * ERRORS
 *  1 - invalid inputs: invalid digits detected in roman numerals a or b
 *      if [ (a || b) != ['M' || 'D' || 'C' || 'L' || 'X' || 'V' || 'I'] 
 *  2 - invalid inputs: inputs a or b are out of range
 *      if [ (a <= 0)||(b <= 0)||(a > 3999)||(b > 3999) ]
 *            \\\\\\\\////////
 *            this is a given since you can't represent zero with roman digits
 *  3 - invalid output: result is going to be out of range  or negative
 *      if (b <= a) - resulting in a negative number
 */

#suite subtract2Romans

#tcase tc6_subtract2Romans

#test tc6_1_chk_invalid_b
      printf("tc6_1_chk_invalid_b: int subtract2Romans( char *b, char *a, char *result)\n");
      char *b_in[] = {"MMMCMXCiX", "dCCCc", "cCCa", "qXXba", "xXXX", "VIIiI", "IIiI"};
      char *a_in[] = {"MMMCMXCIX", "CM",    "CD",   "XC",    "XL",   "IX",    "IV"  };
      int ec_out[] = {         1,       1,       1,    1,      1,     1,       1    };
      char result[100];
      result[0] = '\0'; //empty string
      int ec;
      int i;
      for (i=0; i<7; i++){
     	 ec = subtract2Romans(b_in[i], a_in[i], &result[0]);
	 printf("b_in: %s  a_in: %s expected_ec: %d actual_ec: %d\n", b_in[i], a_in[i], ec_out[i], ec);
	 fail_unless(ec == 1, "tc6_1 failed w ec: %d", ec);
	 }

#test tc6_2_chk_invalid_a
      printf("tc6_2_chk_invalid_a: int subtract2Romans( char *b, char *a, char *result)\n");
      char *a_in[] = {"MMMCMXCiX", "dCCCc", "cCCa", "qXXba", "xXXX", "VIIiI", "IIiI"};
      char *b_in[] = {"MMMCMXCIX", "CM",    "CD",   "XC",    "XL",   "IX",    "IV"  };
      int ec_out[] = {         1,       1,       1,    1,      1,     1,       1    };
      char result[100];
      result[0] = '\0'; //empty string
      int ec;
      int i;
      for (i=0; i<7; i++){
     	 ec = subtract2Romans(b_in[i], a_in[i], &result[0]);
	 printf("b_in: %s  a_in: %s expected_ec: %d actual_ec: %d\n", b_in[i], a_in[i], ec_out[i], ec);
	 fail_unless(ec == 1, "tc6_2 failed w ec: %d", ec);
	 }

#test tc6_3_chk_invalid_ab
      printf("tc6_3_chk_invalid_a: int subtract2Romans( char *b, char *a, char *result)\n");
      char *a_in[] = {"MMMCMXCiX", "dCCCc", "cCCa", "qXXba", "xXXX", "VIIiI", "IIiI"};
      char *b_in[] = {"MMMCMXCiX", "dCCCc", "cCCa", "qXXba", "xXXX", "VIIiI", "IIiI"};
      int ec_out[] = {         1,       1,       1,    1,      1,     1,       1    };
      char result[100];
      result[0] = '\0'; //empty string
      int ec;
      int i;
      for (i=0; i<7; i++){
     	 ec = subtract2Romans(b_in[i], a_in[i], &result[0]);
	 printf("b_in: %s  a_in: %s expected_ec: %d actual_ec: %d\n", b_in[i], a_in[i], ec_out[i], ec);
	 fail_unless(ec == 1, "tc6_3 failed w ec: %d", ec);
	 }

#test tc6_4_chk_valid_ab
      printf("tc6_4_chk_valid_ab:  int subtract2Romans( char *b, char *a, char *result)\n");
      char *b_in[] = {  "IX", "XI", "XIII", "XVI", "XVIII", "XX", "XIII"};
      char *a_in[] = {   "I", "II", "III", "IIII",    "V",  "VI", "VII"};
      //char *expect[]= {"VIII", "IX",   "X",  "XII", "XIII", "XIV", "VI"};
      int ec_out[] = { 0,      0,      0,    0,      0,     0,      0 };
      char result[100];
      result[0] = '\0'; //empty string
      int ec;
      int i;
      for (i=0; i<7; i++){
     	 ec = subtract2Romans(b_in[i], a_in[i], &result[0]);
	 printf("b_in: %s  a_in: %s expected_ec: %d actual_ec: %d result: %s\n", b_in[i], a_in[i], ec_out[i], ec, &result[0]);
	 fail_unless(ec == 0, "tc6_4 failed w ec: %d", ec);
	 }

#test tc6_5_invalidIORange
      printf("tc6_5_invalidIORange:  int subtract2Romans( char *b, char *a, char *result) \n");
      char *b_in[] = { "MMMCMXCIX",  "MMMCMXCX",        "I",   "I",  "XIV"  };
      char *a_in[] = {         "I",         "I", "MMMCMXCX",   "V",    "V"  }; 
      //char rslt[]= {"MMMCMXCVIII",      "ec2",      "ec2", "ec3",    "IX"  };
      int ec_out[] = {          0,           2,          2,      3,     0   };
      char result[100];

      int ec;
      int i;
      for (i=0; i<5; i++){
      	 result[0] = '\0'; //empty string
     	 ec = subtract2Romans(b_in[i], a_in[i], &result[0]);
	 printf("b_in: %s  a_in: %s expected_ec: %d actual_ec: %d, result: %s\n", b_in[i], a_in[i], ec_out[i], ec, &result[0]);
	 switch(i){
	 case 0:
	      fail_unless(ec == 0, "tc6.5 failed w ec: %d", ec);
	      break;
	 case 1:
	      fail_unless(ec == 2, "tc6.5 failed w ec: %d", ec);
	      break;
	 case 2:
	      fail_unless(ec == 2, "tc6.5 failed w ec: %d", ec);
	      break;
	 case 3:
	      fail_unless(ec == 3, "tc6.5 failed w ec: %d", ec);
	      break;
	 case 4:
	      fail_unless(ec == 0, "tc6.5 failed w ec: %d", ec);
	      break;
	 default:
	      break;
	 }	 
      }

#test tc6_7_validSubtractions
      printf("tc6_7_validSubtractions:  int subtract2Romans( char *b, char *a, char *result) \n");
      char *b_in[] =  { "MCCXIV",      "MMCCCXLIX",   "CMX", "CCXII", "CLXXXIII",  "XX", "XIII"};  //c=b+a  b
      char *a_in[] =  {"DCCCXLV",              "I",     "X", "CXXII",    "CXXII", "XIV",   "VI"};  //a      a
      char *expect[]= {"CCCLXIX",    "MMCCCXLVIII",    "CM",    "XC",      "LXI",  "VI",  "VII"};  //b      b-a
      char result[100];
      int ec;
      int i;
      for (i=0; i<7; i++){
         result[0] = '\0'; //empty string
     	 ec = subtract2Romans(b_in[i], a_in[i], &result[0]);
	 printf("b_in: %s  a_in: %s expected: %s actual: %s ec: %d\n", b_in[i], a_in[i], expect[i], &result[0], ec);
	 ck_assert_str_eq(&result[0], expect[i]);
	 }